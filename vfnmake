#!/usr/bin/env perl

use strict;
use File::Find;
use FindBin;
use File::Copy;
use Getopt::Long;
Getopt::Long::Configure("posix_default",
                        "gnu_compat",
                        "bundling",
                        "no_ignore_case",
                        "no_auto_abbrev");
use Pod::Usage;
my $doc;
my $docmsg;
if ( -f "$FindBin::RealBin/README.pod" && $FindBin::RealScript eq "vfnmake" ) {
    $doc    = "$FindBin::RealBin/README.pod";
    $docmsg = "\nTry `vfnmake --help'\n";
}

# variables
my $src;
my $binDir;
my $objsDir;
my @cc;
my @cxx;
my $dcc;
my $dcxx;
my @cflags;
my @cxxflags;
my @lflags;
my @libs;
my @pkgs;
my $name;
my $O;
my $echo;
my $quiet;
my $stdout;
my $ignore;
my $asm;
my $configName = "vfnmake.conf";
my $qt;
my $convert;
my $run;

my $file;


while ($ARGV[0] eq '-f' || $ARGV[0] eq '--file' || $ARGV[0] eq '-d' || $ARGV[0] eq '--chdir' || $ARGV[0] eq '--convert') {
    if ($ARGV[0] eq '-f' || $ARGV[0] eq '--file') {
        shift;
        $configName = $ARGV[0];
        shift;
    } elsif ($ARGV[0] eq '-d' || $ARGV[0] eq '--chdir') {
        shift;
        chdir $ARGV[0];
        shift;
    } elsif ($ARGV[0] eq '--convert') {
        shift;
        $convert = 1;
    }
}

# config load
if ( -f $configName ) {
    open($file, '<', $configName);
    while (my $line = <$file>) {
        my $line2;
        if ($convert) {
            $line2 = <$file>;
            $line2 =~ s/^\s*//;
        } else {
            $line2 =  $line;
            $line  =~ s/^\s*([^:]*:).*$/$1/;
            $line2 =~ s/^\s*[^:]*:\s*(.*)$/$1/;
        }
        if ($line eq "libs:\n") {
            @libs = split /\s+/, $line2;
        } elsif ($line eq "pkgs:\n") {
            @pkgs = split /\s+/, $line2;
        } elsif ($line eq "cflags:\n") {
            @cflags   = split /\s+/, $line2;
        } elsif ($line eq "cxxflags:\n") {
            @cxxflags = split /\s+/, $line2;
        } elsif ($line eq "lflags:\n") {
            @lflags = split /\s+/, $line2;
        } elsif ($line eq "O:\n") {
            chomp ($O = $line2);
        } elsif ($line eq "src_directory:\n") {
            chomp ($src = $line2);
        } elsif ($line eq "bin_directory:\n") {
            chomp ($binDir = $line2);
        } elsif ($line eq "objs_directory:\n") {
            chomp ($objsDir = $line2);
        } elsif ($line eq "cc:\n") {
            @cc  = split /\s+/, $line2;
        } elsif ($line eq "cxx:\n") {
            @cxx = split /\s+/, $line2;
        } elsif ($line eq "debug_cc:\n") {
            chomp ($dcc = $line2);
        } elsif ($line eq "debug_cxx:\n") {
            chomp ($dcxx = $line2);
        } elsif ($line eq "echo:\n") {
            chomp ($echo = $line2);
        } elsif ($line eq "name:\n") {
            chomp ($name = $line2);
        } elsif ($line eq "asm:\n") {
            chomp ($asm = $line2);
        } elsif ($line eq "qt:\n") {
            chomp ($qt = $line2);
        }
    }
    close($file);
}

# argument parsing
GetOptions(
           'cc=s'          => sub { @cc  = split /\s*,\s*/, $_[1] },
           'cxx=s'         => sub { @cxx = split /\s*,\s*/, $_[1] },
           'dcc=s'         => \$dcc,
           'dcxx=s'        => \$dcxx,

           'src=s'         => \$src,
           'bin=s'         => \$binDir,
           'objs=s'        => \$objsDir,
           'name=s'        => \$name,

           'cflags=s'      => sub { @cflags   = split /\s*,\s*/, $_[1]  },
           'cflag|c=s'     => sub {      addToArray($_[1], \@cflags)    },
           'Cflag|C=s'     => sub { removeFromArray($_[1], \@cflags)    },

           'cxxflags=s'    => sub { @cxxflags = split /\s*,\s*/, $_[1]  },
           'cxxflag|x=s'   => sub {      addToArray($_[1], \@cxxflags)  },
           'Cxxflag|X=s'   => sub { removeFromArray($_[1], \@cxxflags)  },

           'lflags=s'      => sub { @lflags   = split /\s*,\s*/, $_[1]  },
           'lflag=s'       => sub {      addToArray($_[1], \@lflags)    },
           'Lflag=s'       => sub { removeFromArray($_[1], \@lflags)    },

           'pkgs=s'        => sub { @pkgs     = split /\s*,\s*/, $_[1]  },
           'pkg|p=s'       => sub {      addToArray($_[1], \@pkgs)      },
           'Pkg|P=s'       => sub { removeFromArray($_[1], \@pkgs)      },

           'libs=s'        => sub { @libs     = split /\s*,\s*/, $_[1]  },
           'lib|l=s'       => sub {      addToArray($_[1], \@libs)      },
           'Lib|L=s'       => sub { removeFromArray($_[1], \@libs)      },

           'O=s'           => \$O,
           'echo|e!'       => \$echo,
           'quiet|q'       => \$quiet,
           'stdout'        => \$stdout,
           'cpp0x!'         => sub { if ($_[1]) {
                                        addToArray("-std=c++0x", \@cxxflags);
                                        @cc    = ("gcc");
                                        @cxx   = ("g++");
                                        $dcc   =  "gcc";
                                        $dcxx  =  "g++";
                                    } else {
                                        removeFromArray("-std=c++0x", \@cxxflags);
                                        @cc    = ();
                                        @cxx   = ();
                                        $dcc   = "";
                                        $dcxx  = "";
                                    } },
           'gcc'           => sub { @cc    = ("gcc");
                                    @cxx   = ("g++");
                                    $dcc   =  "gcc";
                                    $dcxx  =  "g++"; },
           'reset'         => sub { @cc       = ();
                                    @cxx      = ();
                                    $dcc      = "";
                                    $dcc      = "";
                                    $src      = "";
                                    $binDir   = "";
                                    $objsDir  = ""; },
           'ignore|i'      => \$ignore,
           'run|r+'        => \$run,
           'asm!'          => sub { if ($_[1]) {
                                        $asm = 32
                                    } else {
                                        $asm = 0
                                    } },
           'asm64!'        => sub { if ($_[1]) {
                                        $asm = 64
                                    } else {
                                        $asm = 0
                                    } },
           'qt!'           => sub { if ($_[1]) {
                                        $qt = 1;
                                    } else {
                                        $qt = 2 # reset
                                    } },
           'configure'     => sub { copy($FindBin::RealBin . '/' . $FindBin::RealScript, "./configure.pl") or die "Copy failed\n";
                                    chmod(0755, "./configure.pl") or "Chmod failed\n"; },
           'help|h'        => sub { pod2usage({ -input => $doc, -verbose => 1 }) or die if $FindBin::RealScript eq "vfnmake";
                                    exit },
           'man'           => sub { pod2usage({ -input => $doc, -verbose => 2 }) or die if $FindBin::RealScript eq "vfnmake";
                                    exit },
          ) or die pod2usage({ -input => $doc, -message => $docmsg });


# default values
unless ($src) {
    if ( -d "src" ) {
        $src = "src";
    } else {
        $src = ".";
    }
}
$binDir  ||= ".";
$objsDir ||= "objs";
@cc        = ("clang",   "gcc") unless @cc;
@cxx       = ("clang++", "g++") unless @cxx;
$dcc     ||= "gcc";
$dcxx    ||= "g++";
$name    ||= "a.out";
$O       //= 2;
$echo    //= 0;
$quiet   //= 0;
$stdout  //= 0;
$ignore  //= 0;
$asm     //= 0;
$qt      //= 0;
if ($qt == 1) {
    addToArray($_, \@pkgs) for ("QtCore", "QtGui");
    addToArray($_, \@libs) for ("pthread");
} elsif ($qt == 2) {
    removeFromArray($_, \@pkgs) for ("QtCore", "QtGui");
    removeFromArray($_, \@libs) for ("pthread");
    $qt = 0;
}



my @CFiles;
find( sub { push @CFiles  , "$File::Find::name" if /\.c$/              and !/^\.?#/ }, $src);
my @CPPFiles;
find( sub { push @CPPFiles, "$File::Find::name" if /^(?!moc_).*\.cpp$/ and !/^\.?#/ }, $src);
my @QTFiles;
find( sub { push @QTFiles , "$File::Find::name" if /_qt\.hpp$/         and !/^\.?#/ }, $src) if $qt;
my @ASMFiles;
find( sub { push @ASMFiles, "$File::Find::name" if /\.(:?asm|s|S)$/    and !/^\.?#/ }, $src) if $asm;

die "No supported files detected\n" if ( !$ignore    and
                                         !@CFiles    and
                                         !@QTFiles   and
                                         !@CPPFiles  and
                                         !($asm and @ASMFiles) );

my @objs =  (@CFiles, @CPPFiles, @ASMFiles);
s#^.*/(.*)\.[^\.]*$#$objsDir/$1.o# foreach @objs;
foreach my $qt (@QTFiles) {
    my $tmp = $qt;
    $tmp =~ s#^.*/(.*)\.[^\.]*$#$objsDir/moc_$1.o#;
    push @objs, $tmp;
}
my $objs =  join(' ', @objs);

my $cflags   = join(' ', @cflags);
my $cxxflags = join(' ', @cxxflags);
my $lflags   = "";
foreach my $flag (@lflags) {
    $lflags .= "$flag ";
}
foreach my $lib (@libs) {
    $lflags .= "-l $lib ";
}
my $pkgs;
if (@pkgs) {
    $pkgs    = join(' ', @pkgs);
    $lflags .= "`pkg-config $pkgs --libs` ";
    $cflags  = "$cflags `pkg-config $pkgs --cflags`";
}
chop $lflags;

$src      =~ s|/$||;
$binDir   =~ s|/$||;
$objsDir  =~ s|/$||;



# choose the first existing compiler from the list
my $cc;
my $cxx;
my $linker;

{
    $cc = selectCompiler(\@cc);
    if (@CFiles) {
        die "There are no valid C compilers in the list\n"   unless cmdExist($cc);
    }

    $cxx = selectCompiler(\@cxx);
    if (@CPPFiles) {
        die "There are no valid C++ compilers in the list\n" unless cmdExist($cxx);
        $linker = "\$(CXX)";
    } else {
        $linker = "\$(CC)";
    }
}


# write the macros
my $make = "CC=$cc\n";
$make .= "CXX=$cxx\n" if @CPPFiles;
$make .= "CFLAGS=\$(O) $cflags
CXXFLAGS=\$(CFLAGS) $cxxflags
O=-O$O
LFLAGS=$lflags
OBJS=$objs\n";

$make .= "ASM=nasm -f elf" if $asm;
$make .= "64"              if $asm == 64;
$make .= "\n";

if ( -f "vfnmake.begin" ) {
    open($file, '<', "vfnmake.begin");
    my $sep = $/;
    undef $/;
    $make .= "\n" . <$file>;
    $/ = $sep;
    close($file);
}

$make .= "
.PHONY: all
all: objs $name";

if ($echo) {
    $make .= "\n
$binDir/$name: \$(OBJS)
	$linker \$(LFLAGS) \$(OBJS) -o \"$binDir/$name\"\n";
} else {
    $make .= "\n
$binDir/$name: \$(OBJS)
	@ echo \"    LINK $binDir/$name\"
	@ $linker \$(LFLAGS) \$(OBJS) -o \"$binDir/$name\"\n";
}


# creating the targets
foreach my $CFile (@CFiles) {
    my $deps = `gcc -MM "$CFile"`;    # some compilers have problems sometimes, so I've hardcoded gcc here
    chomp $deps;
    if ($echo) {
        $make .= "
$objsDir/$deps
	\$(CC) \$(CFLAGS) -c \"$CFile\" -o \$@";
    } else {
        $make .= "
$objsDir/$deps
	@ echo \"    CC   $CFile\"
	@ \$(CC) \$(CFLAGS) -c \"$CFile\" -o \$@";
    }
}
foreach my $CPPFile (@CPPFiles) {
    my $deps = `g++ -MM "$CPPFile"`;
    chomp $deps;
    if ($echo) {
        $make .= "
$objsDir/$deps
	\$(CXX) \$(CXXFLAGS) -c \"$CPPFile\" -o \$@";
    } else {
        $make .= "
$objsDir/$deps
	@ echo \"    CXX  $CPPFile\"
	@ \$(CXX) \$(CXXFLAGS) -c \"$CPPFile\" -o \$@";
    }
}

if ($qt) {
    $make .= "
$src/moc:
	@ mkdir \"$src/moc\"
.PRECIOUS: $src/moc/moc_\%_qt.cpp";
    if ($echo) {
        $make .= "
$src/moc/moc_\%_qt.cpp: $src/moc $src/\%_qt.hpp
	moc \"$src/\$*_qt.hpp\" -o \$@
objs/moc_\%_qt.o: $src/moc/moc_\%_qt.cpp
	\$(CXX) \$(CXXFLAGS) -c \"$src/moc/moc_\$*_qt.cpp\" -o \$@";
    } else {
        $make .= "
$src/moc/moc_\%_qt.cpp: $src/moc $src/\%_qt.hpp
	@ echo \"    MOC  $src/\$*_qt.hpp\"
	@ moc \"$src/\$*_qt.hpp\" -o \$@
objs/moc_\%_qt.o: $src/moc/moc_\%_qt.cpp
	@ echo \"    CXX  $src/moc/moc_\$*_qt.cpp\"
	@ \$(CXX) \$(CXXFLAGS) -c \"$src/moc/moc_\$*_qt.cpp\" -o \$@";
    }
}

if ($asm) {
    foreach my $ASMFile (@ASMFiles) {
        my $ofile = $ASMFile;
        $ofile =~ s#^.*/(.*)\.[^\.]*$#$objsDir/$1.o#;
        if ($echo) {
            $make .= "
$ofile: $ASMFile
	\$(ASM) \"$ASMFile\" -o \$@";
        } else {
            $make .= "
$ofile: $ASMFile
	@ echo \"    ASM  $ASMFile\"
	@ \$(ASM) \"$ASMFile\" -o \$@";
        }
    }
}


$make .= "\n
objs:
	@ mkdir \"$objsDir\"
.PHONY: c clean
c: clean
clean:
	@ if [ -d \"$objsDir\" ]; then rm -r \"$objsDir\"; fi
	@ rm -f \"$binDir/$name\"\n";
$make .= "	@ if [ -d \"$src/moc\" ];then rm -r \"$src/moc\"; fi\n" if $qt;
$make .= "	@ echo \"    CLEAN\"
.PHONY: f fresh
f: fresh
fresh: clean
	@ make all --no-print-directory
.PHONY: r run
r: run
run: all
	@ ./$binDir/$name

.PHONY: d debug
d: debug
debug: CFLAGS += -DDEBUG -g
debug: O=-O0
debug: CC=$dcc
debug: CXX=$dcxx\n";

$make .= "debug: ASM += -g\n" if $asm;

$make .= "debug: all

# Emacs flymake-mode
.PHONY: check-syntax
check-syntax:
	g++ \$(CXXFLAGS) -fsyntax-only -Wall -o /dev/null -S \$(CHK_SOURCES)\n";

if ( -f "vfnmake.end" ) {
    open($file, '<', "vfnmake.end");
    my $sep = $/;
    undef $/;
    $make .= "\n" . <$file>;
    $/ = $sep;
    close($file);
}

if ($stdout) {
    print "$make";
} else {
    open($file, '>', "Makefile") or die;
    print $file "$make";
    close($file);
}


# config save
my $config;
my @config = (
              [ cc              => \@cc       ],
              [ cxx             => \@cxx      ],
              [ debug_cc        => $dcc       ],
              [ debug_cxx       => $dcxx      ],
              [ libs            => \@libs     ],
              [ pkgs            => \@pkgs     ],
              [ O               => $O         ],
              [ cflags          => \@cflags   ],
              [ cxxflags        => \@cxxflags ],
              [ lflags          => \@lflags   ],
              [ name            => $name      ],
              [ src_directory   => $src       ],
              [ bin_directory   => $binDir    ],
              [ objs_directory  => $objsDir   ],
              [ echo            => $echo      ],
              [ asm             => $asm       ],
              [ qt              => $qt        ],
             );

for my $p (@config) {
    my $str;
    if (ref $p->[1] eq 'ARRAY') {
        $str = join(' ', @{$p->[1]});
    } else {
        $str = $p->[1];
    }
    $config .= printColumns($p->[0] . ':', $str, 20) . "\n";
}

open($file, '>', $configName) or die;
print $file "$config";
close($file);
print "$config" unless $quiet or $stdout;


sub addToArray {
    my ($value, $array) = @_;
    push @$array, $value unless grep {$_ eq $value} @$array;
}
sub removeFromArray {
    my ($value, $array) = @_;
    @$array = grep {$_ ne $value} @$array;
}
sub cmdExist {
    return !system("command -v \"$_[0]\" > /dev/null 2> /dev/null");
}
sub selectCompiler {
    my @list = @{$_[0]};
    my $compiler = "";
    do {
        $compiler = shift @list;
    } while (@list != 0 &&
             !cmdExist($compiler));
    $compiler = "" unless cmdExist($compiler);
    return $compiler;
}
sub printColumns {
    my ($first, $second, $width) = @_;
    $first .= ' ' x ($width - length($first));
    my $ret = $first . $second;
    $ret =~ s/\s*$//;
    return $ret;
}

system("make")     if $run;
system("./$name")  if $run >= 2 and not $?;
